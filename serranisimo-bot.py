import logging
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, KeyboardButton, ReplyKeyboardMarkup
from telegram.ext import Updater, CommandHandler, CallbackContext, CallbackQueryHandler, MessageHandler, Filters
import openai
from dotenv import load_dotenv
import os

# Cargar las variables del .env
load_dotenv()
TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

openai.api_key = OPENAI_API_KEY

# Inicializaci√≥n de logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# Definici√≥n del diccionario de productos:
PRODUCTS = {
    "Fritada üê∑": 10.00,
    "Yahuarlocro üêë": 9.50,
    "Guatita üêÆ": 9.50,
    "Seco de chivo üêê": 9.50,
    "Empanada de morocho ü•ü": 2.00,
    "Humita üåΩ": 1.50,
    "Higos con queso üç®": 2.50,
    "Pristi√±os con miel ü•û": 2.50,
    "Jugo de frutas üßÉ": 2.00,
    "Coca-Cola ü•§": 1.50,
    "Cerveza üç∫": 2.50
    }

# Funci√≥n que se ejecuta cuando un usuario inicia el bot:
def start(update: Update, context: CallbackContext) -> None:
    user_name = update.message.from_user.first_name
    greeting_msg = f'¬°Hola, {user_name}! Bienvenido al bot de Serran√≠simo üë®üèΩ‚Äçüåæü§© ¬øEn qu√© podemos ayudarte?'

    # Botones de interacci√≥n iniciales:
    keyboard = [
        [InlineKeyboardButton("Men√∫ üòã", callback_data="productos"),
        InlineKeyboardButton("Comentarios y sugerencias üôãüèª‚Äç‚ôÇÔ∏è", callback_data="feedback")]
        ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Enviar una imagen
    with open('images/logo.png', 'rb') as photo:
        context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=photo
        )

    # Inicializar el carrito
    context.user_data['cart'] = {}

    # Inicializar el estado
    context.user_data['state'] = 'initiated'

    update.message.reply_text(greeting_msg, reply_markup=reply_markup)

# Funci√≥n para an√°lisis de sentimiento con GPT-3.5 en la secci√≥n "Comentarios y recomendaciones":
def analyze_sentiment(text: str) -> str:
    """
    Analiza el sentimiento de un texto utilizando GPT-3.5.
    """
    # Formulamos una pregunta espec√≠fica para el modelo en formato de chat
    messages = [
        {"role": "system", "content": "You are a highly trained sentiment analysis expert, specialized in assessing text messages from restaurant customers. \
            Your expertise lies in distinguishing subtle nuances in feedback to accurately categorize sentiments. Use your expertise to provide the most precise sentiment evaluation possible."},
        {"role": "user", "content": f"¬øWhat is the general feeling of this comment? '{text}'"}
    ]

    # Enviamos la pregunta al modelo usando el endpoint de chat
    response = openai.ChatCompletion.create(
      model="gpt-3.5-turbo-0301",
      messages=messages
    )
    # Procesamos la respuesta
    sentiment_response = response.choices[0].message['content'].strip()
    if "positive" in sentiment_response:
        return "positive"
    elif "negative" in sentiment_response:
        return "negative"
    else:
        return "neutral"

# Funci√≥n para manejar el feedback del usuario en "Comentarios y recomendaciones":
def handle_feedback(update: Update, context: CallbackContext, feedback: str) -> None:
    """ Maneja el feedback del usuario y env√≠a una respuesta basada en el sentimiento """
    
    user_name = update.message.from_user.first_name
    
    # Invoca a la funci√≥n que analiza sentimientos:
    sentiment = analyze_sentiment(feedback)
    
    # Devuelve un mensaje dependiendo del resultado de analyze_sentiment():
    if sentiment == "positive":
        update.message.reply_text(f"¬°Gracias por tus amables palabras, {user_name}! Trabajamos para brindarte el mejor servicio. üòä")
    elif sentiment == "negative":
        update.message.reply_text(f"Lamentamos que no est√©s satisfecho, {user_name}. Una operadora se comunicar√° contigo por este medio üë©üèªüì≤. Agradecemos tu feedback y trabajaremos en mejorar.")
    else:
        update.message.reply_text(f"¬°Gracias por tu feedback, {user_name}!. Siempre buscamos mejorar y valoramos tus comentarios. üëç")
    
    context.user_data['state'] = None

# Funci√≥n para calcular el total del carrito:
def calculate_total(cart):
    total = sum(PRODUCTS[item] * quantity for item, quantity in cart.items())
    return total

# Funci√≥n que despliega la botonera del men√∫ en el chat.
def display_menu(query, context: CallbackContext) -> None:
    """
    Despliega la botonera del men√∫ en el chat.
    """
    message = "Aqu√≠ tienes nuestro men√∫:\n\n"
    for product, price in PRODUCTS.items():
        message += f"{product}: ${price:.2f}\n"
    
    # Lista de botones de los productos + bot√≥n "VER CARRITO üõí"
    product_buttons = [[InlineKeyboardButton(product, callback_data=product)] for product in PRODUCTS.keys()]
    cart_button = [InlineKeyboardButton("VER CARRITO üõí", callback_data="vercarrito")]
    keyboard = product_buttons + [cart_button]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    query.message.reply_text(message, reply_markup=reply_markup)

# Funci√≥n que controla el bot√≥n del carrito:
def view_cart(query, context: CallbackContext) -> None:
    """
    Funci√≥n que controla el bot√≥n del carrito
    """
    cart = context.user_data.get('cart', {})
    if not cart:
        message = "Tu carrito est√° vac√≠o... üòî ¬°ll√©nalo de cosas deliciosas! ü§§"
    else:
        message = "Contenido de tu carrito: üõí\n\n"
        for product, quantity in cart.items():
            message += f"{product}: {quantity}\n"

    # Bot√≥n para volver al men√∫
    keyboard = [[InlineKeyboardButton("Volver al Men√∫ üîÑ", callback_data="menu")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    query.message.reply_text(message, reply_markup=reply_markup)

# Funci√≥n para solicitar la localizaci√≥n del cliente:
def request_location(update: Update, context: CallbackContext) -> None:
    """Solicita la localizaci√≥n al usuario despu√©s de elegir 'Por hoy ya no...' en la opci√≥n de agregar m√°s productos"""
    
    # Calcula el valor total de la orden:
    total_invoice = calculate_total(context.user_data['cart'])
    
    # Genera el mensaje de total de la orden y solicita localizaci√≥n:
    update.callback_query.message.reply_text(
        f"¬°Gracias por tu pedido! El valor total de tu orden es ${total_invoice:.2f}. \
            Por favor, comparte tu ubicaci√≥n utilizando el bot√≥n 'Clip' üìé y seleccionando 'Ubicaci√≥n' üìç",
        reply_markup=ReplyKeyboardMarkup(
            [[KeyboardButton(text="Enviar ubicaci√≥n", request_location=True)]],
            one_time_keyboard=True
        )
    )
    context.user_data['state'] = 'waiting_for_location'

def handle_location(update: Update, context: CallbackContext) -> None:
    user_location = update.message.location
    latitude = user_location.latitude
    longitude = user_location.longitude
    
    # Guardar la ubicaci√≥n en context.user_data:
    context.user_data['location'] = {
        'latitude': latitude,
        'longitude': longitude
    }
    
    # Luego de guardar la ubicaci√≥n, solicita m√©todo de pago
    request_payment_method(update, context)

# Funci√≥n que solicita indicar m√©todo de pago:
def request_payment_method(update: Update, context: CallbackContext) -> None:
    """Solicita al usuario seleccionar un m√©todo de pago despu√©s de proporcionar su direcci√≥n"""
    keyboard = [
        [InlineKeyboardButton("üíµ Efectivo", callback_data="payment_cash")],
        [InlineKeyboardButton("üí≥ Tarjeta de cr√©dito", callback_data="payment_credit_card")],
        [InlineKeyboardButton("üèß Tarjeta de d√©bito", callback_data="payment_debit_card")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    update.message.reply_text("¬°Gracias por proporcionar tu ubicaci√≥n! Ahora, selecciona tu m√©todo de pago: üí≤",
                              reply_markup=reply_markup)

# Funci√≥n que maneja las respuestas de los usuarios:
def handle_user_reply(update: Update, context: CallbackContext) -> None:

    user_name = update.message.from_user.first_name

    # Si el usuario acaba de iniciar el chat, ignoramos su mensaje y cambiamos el estado a None:
    if context.user_data.get('state') == 'initiated':
        context.user_data['state'] = None
        update.message.reply_text("Por favor, utiliza los botones del men√∫ para seleccionar productos")
        return
    
     # El bot est√° esperando una ubicaci√≥n:
    elif context.user_data.get('state') == 'waiting_for_location':
        update.message.reply_text(f"Por favor {user_name}, comparte tu ubicaci√≥n utilizando el bot√≥n 'Clip' üìé y seleccionando 'Ubicaci√≥n' üìç")
        return

    # El bot est√° esperando feedback (felicitaciones o sugerencias):
    elif context.user_data.get('state') == 'waiting_for_feedback':
        feedback = update.message.text
        handle_feedback(update, context, feedback)
        return

    # Si el estado es None o no existe, muestra el saludo inicial y el men√∫:
    elif not context.user_data.get('state'):
        start(update, context)    

# Funci√≥n para manejar las interacciones con los botones
def button(update: Update, context: CallbackContext) -> None:
    """"Funci√≥n para manejar las interacciones con los botones."""

    query = update.callback_query

    user_name = query.from_user.first_name  # Accede al nombre del usuario desde aqu√≠

    query.answer()
    
    logging.info(f"Received callback data: {query.data}")

    # Acci√≥n cuando se selecciona un producto
    if query.data in PRODUCTS:
        if query.data in context.user_data['cart']:
            context.user_data['cart'][query.data] += 1
        else:
            context.user_data['cart'][query.data] = 1

        logging.info(f"Current cart: {context.user_data['cart']}")

        total_price = calculate_total(context.user_data['cart'])

        # Botones para seleccionar m√°s productos o pasar a las siguientes opciones:
        keyboard = [
            [InlineKeyboardButton("¬°Por su puesto! üòé", callback_data="yes"),
             InlineKeyboardButton("Por hoy ya no... üò≥", callback_data="no")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        query.edit_message_text(
            f"Has a√±adido {query.data} a tu carrito. Hasta el momento, tu total es ${total_price:.2f}. ¬øDeseas algo m√°s?", 
            reply_markup=reply_markup
            )

    # Acci√≥n cuando se selecciona "Comentarios y sugerencias:"
    elif query.data == "feedback":
        query.edit_message_text(f"Por favor {user_name}, comparte tus comentarios o sugerencias con nosotros: üí¨")
        context.user_data['state'] = 'waiting_for_feedback'

    # Acci√≥n cuando se selecciona "Men√∫"
    elif query.data == "productos":
        display_menu(query, context)
        
    # Acci√≥n cuando se selecciona "S√≠"
    elif query.data == "yes":
        display_menu(query, context)

    # Acci√≥n cuando se selecciona "No"
    elif query.data == "no":
        request_location(update, context)
        
    # Acci√≥n cuando se selecciona "Ver carrito"
    if query.data == "vercarrito":
        view_cart(query, context)

    elif query.data == "menu":
        display_menu(query, context)

    # Acci√≥n cuando se selecciona un m√©todo de pago
    elif query.data.startswith("payment_"):
        context.user_data['payment_method'] = query.data
        query.edit_message_text(f"¬°Muchas gracias, {user_name}! ¬°Nuestro motorista üõµ estar√° contigo en 30-40 minutos ‚è≥ ten listo tu m√©todo de pago! ¬°Disfruta tu comida!")
        context.user_data['state'] = None

# Funci√≥n principal
def main() -> None:
    updater = Updater(TOKEN, use_context=True)

    dp = updater.dispatcher

    # Manejadores de botones:
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CallbackQueryHandler(button))
    dp.add_handler(MessageHandler(Filters.location, handle_location))
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_user_reply))

    updater.start_polling()
    updater.idle()

if __name__ == '__main__':
    main()